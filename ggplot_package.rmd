# The ggplot2 Library

In addition to the built-in plotting routines, there are several additional graphics libraries available for creating output.  The one I prefer is ggplot2 written by Hadley Wickham.  His approach in designing this library a philosophy of graphics depicted in Leland Wilkson's (2005) book The Grammar of Graphics. As I understand it, the idea is that a graphical display consists of several layers of information. These layers may include:

* The underlying data.  
* Mapping of the data onto one or more axes.  
* Geometric representations of data as points, lines, and/or areas.  
* Transformations of the axes into different coordinate spaces (e.g., cartesian, polar, etc.) or the data onto different scales (e.g., logrithmic)  
* Specification of subplots.

In the normal plotting routines discussed before, configuration of these layers were specified as arguments passed to the plotting function (`plot()`, `boxplot()`, etc.). The ggplot2 library takes a different approach, allowing you to specify these components separately and literally add them together like components of a linear model.

## Univariate Data

If you do not already have the library installed, you can install it using the normal approach

```{r eval=FALSE}
install.packages("ggplot2")
```

and then load it into memory as usual

```{r message=FALSE}
library(ggplot2)
```

To construct a plot, we need to first establish the data layer.  This is done by making a call to `ggplot()` and passing it two components:

* A data.frame object that is holding the data.  All data to be plot must be in a data.frame, which isn't that big of a deal as this is the main container within which we keep our data.
* An aesthetic for the data (passed as aes()), depicting which variable is going to be plot on which axis as well as any visual parameters on that plot that may be controlled by variables in the data.frame (e.g., color, symbol, etc.).

The general form for this is:

```{r eval=FALSE}
ggplot( theData, aes(x=theXvariable,y=theYvariable))
```


where the named variables for x- and y- are the column names in the theData.

To this object we add at least one geometry layer we want to use to plot the data contained in the data layer.  For a histogram, we can use

```{r message=FALSE}
ggplot( iris, aes(x=Sepal.Width)) + geom_histogram()
```

which results in the image below.  If you do not pass any arguments to the `geom_histogram()` function, it makes a default partitioning on the data (as indicated in the output) much the same way we saw the `hist()` function did previously.

It is possible to split up the data layer and subsequent layers into several different calls if that makes it easier.  I often do this when I am creating a graphic and want to try out some different layouts.

```{r}
p <- ggplot( iris, aes(x=Sepal.Width)) 
```


Then with subsequent calls to the data layer, I can just play around with the other parts to get the plot.  This approach is particularly helpful as the complexity of the figure increases and you have many layers added onto it such as

```{r}
p + geom_histogram( binwidth=0.2 ) + xlab("Sepal Width") + ylab("Frequency") + theme_bw()
```

where I am configuring the axes, specifying a different width for the bins, and changing the overall color theme.

In a similar fashion, we can create density plots and overlay them onto these histograms

```{r}
p <- p + geom_density( fill="red") 
p <- p + geom_histogram( binwidth=0.1, fill="orange", color="black", aes(y=..density..), alpha=0.9)  
p + xlab("Sepal Width") + ylab("Frequency")
```

by sequentially adding the layers.  The plot itself does not show until the last command is given, where you are displaying the value of p and its axes labels.  Of particular note here is that I had to specify a different `aes()` for the `geom_histogram()` function.  What I passed to it was “..density..” which is a shorthand notation for `ggplot()` to return the data not as raw counts but as a density frequency.  This is because the `geom_density()` function plots the y-axis data as a frequency, not a count and if you don't tell them to be on the same scale, the histograms will have a range of 0-26 whereas the density plot will be on 0-1.  Also, the order in which you add the layers creates the stacking of the data—the histogram is over the top of the density plot because it was added to the data layer after the density layer.

Aesthetics can also be augmented by subsequent geometry layers.  In the iris example, we can plot the density of the sepal width, partitioned by species, but this time we can put that information into the call on the `geom_density()` function rather than having it all in the `aes()` call in the `ggplot()` data layer. This may be a bit confusing, but there are many times when you are plotting two ore more kinds of data that just cannot be depicted in a single data.frame object.  The calls 
```{r}
p + geom_density( aes(fill=Species), alpha=0.7 )
```

and 

```{r}
ggplot( iris, aes(x=Sepal.Width,fill=Species) ) + geom_density( alpha=0.7 )
```

and

```{r}
ggplot() + geom_density( aes(x=Sepal.Width,fill=Species), data=iris, alpha=0.7 )
```

all produce the same exact figure.  There is quite a bit of flexibility that comes in handy when crafting complicated graphics (n.b., that should not be the goal, graphics should be reality interpreted).

And for completeness, we can do the same thing with a geom_histogram() and have the bars plot in a staggered fashion (`position=”dodge”` in the parlance of ggplot).

```{r}
p + geom_histogram( aes(fill=Species), binwidth=0.1, position="dodge")
```

The result of which provides its own legend.  For bar-like plots the fill= part will color the entire bar, if you use color= it will make that the color of the borders around the bar.  

By default, ggplot uses those colors for categories but you can easily specify a color palette of your choosing (see Color Palettes for more information on how to manipulate colors).

## Bivariate Data

For bivariate data, the same kinds of plots can be created, depending upon the kind of predictor and response variables you have.  For simplicity, I will keep the designation of aesthetics within the `ggplot()` function for the following examples.
Boxplots for sepal width across species can be created just as before.  The error bars are slightly different (they don't have the horizontal bar on them), but most of the rest is identical.  The only difference I can see directly is that the width of the notch is not based upon the confidence around the median but is depicted as a fraction of the box size.  I may be in err, but this seems to be what the help file says for the description for the parameter notchwidth which can be changed.  If this is the case, it seems there may be some room for additional code here.

```{r}
ggplot(iris, aes(x=Species, y=Sepal.Length)) + geom_boxplot(notch = TRUE) + xlab("Iris Species") + ylab("Sepal Width (cm)")
```

Scatter plots are handled by the geometric layer `geom_point()`.  You can specify alternative shapes for different categories (as done with `pch=` in the normal R plotting) by passing the column name of the grouping factor as shape= (or alternatively `color=` if you want them to be color differences). Here is an example looking at sepal length and width across different species.

```{r}
ggplot(iris,aes(x=Sepal.Length,y=Sepal.Width, shape=Species)) + geom_point()
```

This figure may be a bit confusing.  You can see a few points where the three species have the same measurements for both sepal length and width—both I. versicolor and *I. virginica* have examples with sepal widths of 3.0cm and lengths of 6.7cm.  For some of these it would be difficult to determine using a graphical output like this if there were more overlap.  In this case, it may be a more informative approach to make plots for each species rather than using different symbols.  In ggplot, there is a facet geometry that can be added to a plot that can pull apart the individual species plots (in this case) and plot them either next to each other (if you are looking at y-axis differences), on top of each other (for x-axis comparisons), or as a grid (for both x- and y- axis comparisons).

This layer is added to the plot using `facet_grid()` and take a ‘functional' argument on which factors will define rows and columns of plots.  Here is an example where I stack plots by species.

```{r}
ggplot( iris, aes(x=Sepal.Width, y=Sepal.Length ) ) + geom_point() + facet_grid(Species~.) + xlab("Sepal Width (cm)") + ylab("Sepal Length")
```

I would argue that this is a much more intuitive display of differences in width than the previous plot.

## Color Palettes

The default plotting colors in R are black and white.  However, there is a rich set of colors available for your plotting needs.  The easiest set are named colors.  At the time of this writing, there are 

```{r}
length(colors())
```

different colors available for your use. Not all are distinct as some overlap.  However the benefit of these colors is that they have specific names, making it easier for you to remember than RGB or hex representations.  Here are a random set of 20 color names.

```{r}
colors()[ sample.int( length(colors()), size=20) ]
```

To use these colors you can call them by name in the col= option to a plot.  Here is an example where I define three named colors and then coerce the `iris$Species` variable into an integer to select the color by species and plot it in a scatter plot (another version of the `pch=` example previously).

```{r}
colors <- c("royalblue1", "orange1", "green3")
cols <- colors[ iris$Species ]
plot( Sepal.Width ~ Sepal.Length, data=iris, col=cols, xlab="Sepal Length (cm)", ylab="Sepal Width (cm)", bty="n", pch=16)
```


There is a lot of colors to choose from, and you are undoubtedly able to fit any color scheme on any presentation you may encounter.

In addition to named colors, there are color palettes available for you to grab the hex value for individual color along a pre-defined gradient.  These colors ramps are:

* `rainbow()`:  A palette covering the visible spectrum  
* `heat.colors()`: A palette ranging from red, through orange and yellow, to white.  
* `terrain.colors()`: A palette for plotting topography with lower values as green and increasing through yellow, brown, and finally white.   
* `topo.colors()`: A palette starting at dark blue (water) and going through green (land) and yellow to beige (mountains).   
* `cm.colors()`: A palette going from light blue through white to pink.  

and are displayed in the following figure.

The individual palette functions return the hex value for an equally separated number of colors along the palette, you only need to ask for the number of colors you are requesting.  Here is an example from the `rainbow()` function.

```{r}
rainbow(10)
```


## RColorBrewer

The ggplot2 library has a slightly more interesting color palette, but it too is often a bit lacking.  You have total control over the colors you produce and can specify them as RGB, hex (e.g. the way the web makes colors), or CMYK.  You can also define your own color palettes.  

To start, the RColorBrewer library provides several palettes for plotting either quantitative, qualitative, or divergent data.  These three groups and the names of individual color palettes can be viewed as:

```{r}
library(RColorBrewer)
display.brewer.all()
```

In ggplot, we can use these palettes as follows.

You can change the default palette in ggplot output adding the `scale_color_brewer()` (and `scale_fill_brewer()` if you are doing fill colors like in a barplot) to the plot.  Here is an example where I change the default palette to the 6th divergent palette.

```{r}
p <- ggplot(iris,aes(x=Sepal.Length,y=Sepal.Width, color=Species)) + geom_point() 
p <- p + xlab("Sepal Length (cm)") + ylab("Sepal Width (cm)")
p + scale_color_brewer(type="div", palette=6)
```


## Saving Imagery

Creating a graphic for display on your screen is only the first step.  For it to be truly useful, you need to save it to a file, often with specific parameters such as DPI or image size, so that you can use it outside of R.  

For normal R graphics, you can copy the current graphical device to a file using `dev.copy()` or you can create a graphic file object and plot directly to it instead of the display.  In both cases, you will need to make sure that you have your graphic formatted the way you like.  Once you have the file configured the way you like, decide on the image format you will want.  Common ones are jpg, png and tiff.  Here are the function arguments for each of the formats.

```
jpeg(filename = "Rplot%03d.jpeg",
     width = 480, height = 480, units = "px", pointsize = 12,
     quality = 75,
     bg = "white", res = NA, ...,
     type = c("cairo", "Xlib", "quartz"), antialias)

png(filename = "Rplot%03d.png",
    width = 480, height = 480, units = "px", pointsize = 12,
     bg = "white",  res = NA, ...,
    type = c("cairo", "cairo-png", "Xlib", "quartz"), antialias)

tiff(filename = "Rplot%03d.tiff",
     width = 480, height = 480, units = "px", pointsize = 12,
     compression = c("none", "rle", "lzw", "jpeg", "zip", "lzw+p", "zip+p"),
     bg = "white", res = NA,  ...,
     type = c("cairo", "Xlib", "quartz"), antialias)
```
     
These are the default values.  If you need a transparent background, it is easiest to use the png file and set `bg=”transparent”`.  If you are producing an image for a publication, you will most likely be given specific parameters about the image format in terms of DPI, pointsize, dimensions, etc.  They can be set here.

To create the image, call the appropriate function above, and a file will be created for your plotting.  You must then call the plotting functions to create your graphic.  Instead of showing up in a graphical display window, they will instead be plot to the file. When done you must tell R that your plotting is now finished and it can close the graphics file.  This is done by calling dev.off().  Here is an example workflow saving an image of a scatter plot with a smoothed line through it using ggplot.

```{r eval=FALSE}
png( filename = "MyCoolGraphic.png", quality=300, bg="transparent", width=1080, height=1080)
ggplot( df, aes(x=PredictorVar, y=ResponseVar)) + geom_point() + stat_smooth(method="loess") + theme_bw()
dev.off()
```

This will create a file MyCoolGraphic.png saved in the same folder as the current working directory.  

To use `dev.copy()` instead, you first make the graphic and then copy the current graphic to a file.  For this example, it would be:

```{r eval=FALSE}
ggplot( df, aes(x=PredictorVar, y=ResponseVar)) + geom_point() + stat_smooth(method="loess") + theme_bw()
dev.copy(device=png,file="MyDevCopyGraphic.png")
dev.off()
```

In general, I prefer the first method as it allows me to specify the specifics of the file in an easier fashion than the second approach.

If you are using ggplot2 graphics, there is a built-in function ggsave() that can also be used to save your currently displaying graphic (or others if you so specify) to file.  Here are the specifics on that function call.

```{r eval=FALSE}
ggsave(filename = default_name(plot), plot = last_plot(),
  device = default_device(filename), path = NULL, scale = 1,
  width = par("din")[1], height = par("din")[2], units = c("in", "cm",
  "mm"), dpi = 300, limitsize = TRUE, ...)
```

Either approach will allow you to produce publication quality graphics.

